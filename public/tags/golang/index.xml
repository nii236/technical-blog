<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on A Blog</title>
    <link>http://nii236.github.io/technical-blog/tags/golang/</link>
    <description>Recent content in Golang on A Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Apr 2016 14:21:40 +0800</lastBuildDate>
    <atom:link href="http://nii236.github.io/technical-blog/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A trading platform in Go</title>
      <link>http://nii236.github.io/technical-blog/post/microservices/</link>
      <pubDate>Wed, 27 Apr 2016 14:21:40 +0800</pubDate>
      
      <guid>http://nii236.github.io/technical-blog/post/microservices/</guid>
      <description>

&lt;h2 id=&#34;the-language:24c62ab0ae8d6139f10d3d52cfeca2af&#34;&gt;The language&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been obsessing over Go lately. I won&amp;rsquo;t go into it much since pretty much everyone else on the internet has at some point or another. And all of the people I know have probably heard me raving about it. The quality of the language itself remains divisive, but I am going to soldier on and just try and build something.&lt;/p&gt;

&lt;h2 id=&#34;the-project:24c62ab0ae8d6139f10d3d52cfeca2af&#34;&gt;The project&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been looking at playing with &lt;a href=&#34;https://github.com/micro/go-micro&#34;&gt;go-micro&lt;/a&gt; and building microservices. Really, I only needed an excuse to build something. I&amp;rsquo;ve come across some decent trading platforms and frameworks online but nothing really built in Go. So that&amp;rsquo;s my project.&lt;/p&gt;

&lt;p&gt;The first step will be to write a client that subscribes to the Interactive Brokers API and publishes the ticker data onto a &lt;a href=&#34;http://nats.io/&#34;&gt;NATS&lt;/a&gt; message bus, which will then be consumed by &lt;a href=&#34;https://influxdata.com/&#34;&gt;InfluxData&amp;rsquo;s&lt;/a&gt; Telegraf NATS connector. This will give me a bunch of data to play with, with helpful time series crunching tools that come for free with InfluxDB (&lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, even an &lt;code&gt;SMA&lt;/code&gt;!).&lt;/p&gt;

&lt;p&gt;Everything will be docker-ised into a swarm. NATS and Influx provide docker containers so that&amp;rsquo;s easy. The single microservices will contain static binaries so (in theory) that will be easy as well.&lt;/p&gt;

&lt;h2 id=&#34;the-snippet:24c62ab0ae8d6139f10d3d52cfeca2af&#34;&gt;The snippet&lt;/h2&gt;

&lt;p&gt;Here is a code snippet that subscribes to the IB API (also docker-ised) and (for now) just logs the values to STDOUT.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func exec(pair string, currency string) {
	log.Infoln(&amp;quot;Starting connection to IB gateway...&amp;quot;, &amp;quot;Pair:&amp;quot;, pair, &amp;quot;, Currency:&amp;quot;, currency)
	options := &amp;amp;ib.EngineOptions{
		Client:           0,
		Gateway:          &amp;quot;192.168.99.100:4003&amp;quot;,
		DumpConversation: false,
	}

	var err error
	e, err = ib.NewEngine(*options)

	defer e.Stop()

	if err != nil {
		log.Fatalln(&amp;quot;ERROR!&amp;quot;, err)
		return
	}
	defer e.Stop()
	log.Infoln(&amp;quot;Done.&amp;quot;)
	log.Infoln(&amp;quot;Setting up contract for subscription...&amp;quot;)
	contract := &amp;amp;ib.Contract{
		Symbol:       pair,
		SecurityType: &amp;quot;CASH&amp;quot;,
		Exchange:     &amp;quot;IDEALPRO&amp;quot;,
		Currency:     currency,
	}

	im, err := ib.NewInstrumentManager(e, *contract)
	defer im.Close()
	ctm, err := ib.NewCurrentTimeManager(e)
	defer ctm.Close()

	if err != nil {
		log.Fatalln(err)
	}

	for {
		select {
		case &amp;lt;-im.Refresh():
			if err := im.FatalError(); err != nil {
				log.Fatalln(err)
			}
			log.Infoln(&amp;quot;Time:&amp;quot;, ctm.Time().UnixNano())
			log.Infoln(&amp;quot;Bid:&amp;quot;, im.Bid())
			log.Infoln(&amp;quot;Ask:&amp;quot;, im.Ask())
			log.Infoln(&amp;quot;Last:&amp;quot;, im.Last())
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the moment CPU usage jumps up to 50% as soon as you connect to the IB Gateway. No idea why but I&amp;rsquo;m just going to assume its a library issue for the time being.&lt;/p&gt;

&lt;p&gt;The repo can be located on &lt;a href=&#34;https://github.com/nii236/nii-finance&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Graviton</title>
      <link>http://nii236.github.io/technical-blog/post/graviton/</link>
      <pubDate>Sun, 15 Nov 2015 16:18:08 +0800</pubDate>
      
      <guid>http://nii236.github.io/technical-blog/post/graviton/</guid>
      <description>&lt;p&gt;I&amp;rsquo;d like to introduce Graviton in this post. Its a name I made up for my project mentioned in a previous post. There&amp;rsquo;s no real point to the name, except that it uses Electron plus Go. So I figured I&amp;rsquo;d choose a cool physics based name that starts with G.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;ll explain the basic steps in communicating between the front and back. In this case a &amp;ldquo;Hello World&amp;rdquo; should do the trick.&lt;/p&gt;

&lt;p&gt;So there are three parts to a graviton app:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Browser front-end&lt;/li&gt;
&lt;li&gt;Node js glue-end&lt;/li&gt;
&lt;li&gt;Golang backend&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first two parts are covered with Electron.js. And the backend is covered by Go, believe it or not.&lt;/p&gt;

&lt;p&gt;Connecting the front-end to the glue-end is done by Electron&amp;rsquo;s internal &lt;code&gt;ipc&lt;/code&gt; package. Its an event based system.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s send a &amp;ldquo;Hello from front-end&amp;rdquo; message from our front-end. I&amp;rsquo;m a react.js guy as well, so that&amp;rsquo;s what I&amp;rsquo;ll be using.&lt;/p&gt;

&lt;p&gt;Create a React component which has a button which calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ipc.send(&#39;SendHello&#39;, &#39;Front-end&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the glue-end, you&amp;rsquo;ll want a handler for this event, which basically just passes this onto the backend&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var client = new todoProto.Todo(&#39;localhost:3000&#39;, grpc.Credentials.createInsecure());

ipc.on(&#39;SendHello&#39;, function(event, arg) {
  client.sendHello({request: arg}, function(err, response) {
    if (err) { console.log(err); }
    event.sender.send(&#39;SendHelloResponse&#39;, response)
  });
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The communication between the glue-end and the backend needs to be declared in a protobuf3 file. The glue-end will also handle the response which will be sent back over IPC to the front-end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;

package Hello;

message SendHelloRequest {
  string request = 1;
}

message SendHelloResponse {
  string response = 1;
}

service Todo {
  rpc SendHello(SendHelloRequest) returns
  (SendHelloResponse);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to handle it in the backend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type sendHelloServer struct{}

// AddTodoService implements pb.AddTodoServer
func (s sendHelloServer) SendHello(ctx context.Context, in *pb.SendHelloRequest) (*pb.SendHelloResponse, error) {
	return &amp;amp;pb.SendHelloResponse{Response: &amp;quot;Hello&amp;quot; + in.Request}, nil
}

func main() {
  port := os.Getenv(&amp;quot;PORT&amp;quot;)
	host := os.Getenv(&amp;quot;HOST&amp;quot;)

	if len(port) == 0 {
		port = &amp;quot;3000&amp;quot;
	}

	if len(host) == 0 {
		host = &amp;quot;localhost&amp;quot;
	}

	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, host+&amp;quot;:&amp;quot;+port)
	if err != nil {
		log.Fatalf(&amp;quot;failed to listen: %v&amp;quot;, err)
	}
	s := grpc.NewServer()
	pb.RegisterSendHelloServer(s, &amp;amp;sendHelloServer{})
	s.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The response from the Go backend is now sent to your node.js glue-end which will forward it to the front-end. Now handle the response over in your front-end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ipc.on(&#39;SendHelloResponse&#39;, (arg) =&amp;gt; {
  console.log(arg);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will see &amp;ldquo;Hello Front-end&amp;rdquo; in your Electron&amp;rsquo;s console everytime you click the button! Amazing!&lt;/p&gt;

&lt;p&gt;I imagine you&amp;rsquo;re thinking something like:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Goddamn that was a LOT of effort for a Hello World&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sure it was. But now you have a cool framework for your Go app! You are Hello World-ing across three different layers! Its a self contained, cross platform, multi-language, HTTP2 streaming enabled microservice!&lt;/p&gt;

&lt;p&gt;The connection between the presentation layer and the backend is handled in Protobuf/gRPC format. Communication is very efficient compared to JSON, uses HTTP/2 and supports streaming, duplex communication and other cool things that I have only begun to explore.&lt;/p&gt;

&lt;p&gt;I would like to imagine that with all this setup you have a scalable system with which you can create cool apps like PopcornTime, Atom and others, except now you can do it with Go.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s pretty damn cool.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>